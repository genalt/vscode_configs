{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Codeforces template": {
		"prefix": "cft",
		"body": [
			"#include <iostream>",
			"#include <vector>",
			"#include <cmath>",
			"#include <set>",
			"#include <map>",
			"#include <unordered_map>",
			"#include <unordered_set>",
			"#include <algorithm>",
			"#include <queue>",
			"#include <deque>",
			"#include <stack>",
			"#include <string>",
			"#include <sstream>",
			"",
			"#define mp make_pair",
			"#define pb push_back",
			"#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
			"#define endl '\\n'",
			"#define int long long",
			"#define uint unsigned long long",
			"#define vi vector<int>",
			"#define ii pair<int,int>",
			"#define vvi vector<vector<int>>",
			"using namespace std;",
			"",
			"int32_t main() {",
			"    IOS;",
			"    int n, m, k;",
			"    return 0;",
			"}"
		],
		"description": "Codeforces template"
	},
	"Sparse Table": {
		"prefix": "sparse",
		"body": [
			"struct ST {",
			"    vector<int> st[10000], lg;",
			"",
			"    ST(const vector<int>& v) {",
			"        lg.assign(v.size() + 1, 0);",
			"        lg[2] = 1;",
			"        for(int i = 3; i <= v.size(); i++)",
			"            lg[i] = lg[i/2] + 1;",
			"        ",
			"        for(int f = 0; f <= lg[v.size()]; f++) {",
			"            st[f].assign(v.size(), 0);",
			"            for(int i = 0; i + (1<<f) <= v.size(); i++)",
			"                if(f == 0)  st[f][i] = v[i];",
			"                else        st[f][i] = max(st[f-1][i],  st[f-1][i + (1<<f)/2]); // OR min here",
			"        }",
			"    }",
			"    int get_m(int i, int j) {",
			"        int f = lg[j - i + 1];",
			"        return max(st[f][i], st[f][j - (1<<f) + 1]); // OR min here",
			"    }",
			"};",
			"",
		],
		"description": "Sparse table"
	},
	"disjoint sets": {
		"prefix": "dsets",
		"body": [
			"",
			"struct disjoint_sets {",
			"  vector<int> roots;",
			"  vector<int> heights;",
			"",
			"  disjoint_sets(int in_size) {",
			"    for (int i = 0; i < in_size; i++) roots.push_back(i);",
			"    heights.assign(in_size, 0);",
			"  }",
			"",
			"  int find(int idx) {",
			"    return (idx == roots[idx]) ? idx : (roots[idx] = find(roots[idx]));",
			"  }",
			"",
			"  void join(int idx1, int idx2) {",
			"    int r1 = find(idx1);",
			"    int r2 = find(idx2);",
			"",
			"    if (r1 == r2) return;",
			"    if (heights[r1] >= heights[r2])",
			"      roots[r2] = r1;",
			"    else",
			"      roots[r1] = r2;",
			"",
			"    if (heights[r1] == heights[r2]) heights[r1]++;",
			"  }",
			"};",
			"",
		],
		"description": "disjoint sets"
	},
	"segment tree": {
		"prefix": "segment",
		"body": [
			"",
			"struct segment_tree {",
			"    vector<int> st, lz;",
			"    int orig_size;",
			"    int rv;",
			"",
			"    segment_tree(const vector<int>& in_arr) {",
			"        orig_size = in_arr.size();",
			"        st.assign(in_arr.size() * 4, 0);",
			"        lz.assign(in_arr.size() * 4, 0);",
			"        build(in_arr, 0, 0, in_arr.size() - 1);",
			"    }",
			"",
			"    int op(int a, int b) {",
			"        // for MIN tree",
			"        //rv = 10000; // max possible value",
			"        //return min(a, b);",
			"",
			"        // for MAX tree",
			"        rv = -10000; //min possible value",
			"        return max(a, b);",
			"        ",
			"        // for SUM tree",
			"        //rv = 0; // 0 value",
			"        //return a + b;",
			"    }",
			"    void build(const vector<int>& in_arr, int idx, int seg_start, int seg_end) {",
			"        if(seg_start == seg_end) {",
			"            st[idx] = in_arr[seg_start];",
			"        } else {",
			"            build(in_arr, idx * 2 + 1, seg_start, (seg_end + seg_start)/2);",
			"            build(in_arr, idx * 2 + 2, (seg_end + seg_start)/2 + 1, seg_end);",
			"            st[idx] = op(st[idx * 2 + 1],  st[idx * 2 + 2]);",
			"        }",
			"    }",
			"",
			"    int req(int start, int end) {",
			"        return req(start, end, 0, 0, orig_size - 1);",
			"    }",
			"",
			"    int req(int start, int end, int idx, int seg_start, int seg_end) {",
			"        if(lz[idx]) {",
			"            st[idx] += (seg_end - seg_start + 1) * lz[idx];",
			"            lz[idx*2 + 1] += lz[idx];",
			"            lz[idx*2 + 2] += lz[idx];",
			"            lz[idx] = 0;",
			"        }",
			"",
			"        if(seg_start > end || seg_end < start) {",
			"            return rv;",
			"        } else if(seg_start >= start && seg_end <= end) {",
			"            return st[idx];",
			"        } else {",
			"            return op(req(start, end, idx * 2 + 1, seg_start, (seg_end + seg_start)/2),",
			"                    req(start, end, idx * 2 + 2, (seg_end + seg_start)/2 + 1, seg_end));",
			"        }",
			"    }",
			"",
			"    void add(int idx, int value) {",
			"        add(idx, idx, value, 0, 0, orig_size - 1);",
			"    }",
			"",
			"    void add(int start, int end, int value) {",
			"        add(start, end, value, 0, 0, orig_size - 1);",
			"    }",
			"",
			"    void add(int start, int end, int value, int idx, int seg_start, int seg_end) {",
			"        if(seg_start > end || seg_end < start) {",
			"            return;",
			"        } else if(seg_start >= start && seg_end <= end) {",
			"            st[idx] += (seg_end - seg_start + 1) * value;",
			"            lz[idx*2 + 1] += value;",
			"            lz[idx*2 + 2] += value;",
			"        } else {",
			"            add(start, end, value, idx * 2 + 1, seg_start, (seg_end + seg_start)/2);",
			"            add(start, end, value, idx * 2 + 2, (seg_end + seg_start)/2 + 1, seg_end);",
			"            st[idx] = op(st[idx*2 + 1], st[idx*2 +2]);",
			"        }",
			"    }",
			"};",
			"",
		],
		"description": "segment tree"
	},
	"All vector items": {
		"prefix": "allin",
		"body": [
			"$1.begin(), $1.end()"
		],
		"description": "get vector iterators"
	},
	"Binomial coefficients": {
		"prefix": "binomialcoeff",
		"body": [
			"int binomialCoeff(int n, int k)",
			"{",
			"    int C[k+1];",
			"    memset(C, 0, sizeof(C));",
			"",
			"    C[0] = 1;  // nC0 is 1",
			"",
			"    for (int i = 1; i <= n; i++)",
			"    {",
			"        // Compute next row of pascal triangle using",
			"        // the previous row",
			"        for (int j = min(i, k); j > 0; j--)",
			"            C[j] = C[j] + C[j-1];",
			"    }",
			"    return C[k];",
			"}"
		],
		"description": "get vector iterators"
	},
	"For loop": {
		"prefix": "rep",
		"body": [
			"for(int $1 = 0; $1 < $2; ++$1) {",
			"}"
		],
		"description": "for loop"
	},
	"BigInteger": {
		"prefix": "bigint",
		"body": [
			"#define BI_MAX 10000 // for strings",
			"class BigInteger {",
			"private:",
			"    string number;",
			"    bool sign;",
			"public:",
			"    BigInteger(); // empty constructor initializes zero",
			"    BigInteger(string s); // \"string\" constructor",
			"    BigInteger(string s, bool sin); // \"string\" constructor",
			"    BigInteger(int n); // \"int\" constructor",
			"    void setNumber(string s);",
			"    const string& getNumber(); // retrieves the number",
			"    void setSign(bool s);",
			"    const bool& getSign();",
			"    BigInteger absolute(); // returns the absolute value",
			"    void operator = (BigInteger b);",
			"    bool operator == (BigInteger b);",
			"    bool operator != (BigInteger b);",
			"    bool operator > (BigInteger b);",
			"    bool operator < (BigInteger b);",
			"    bool operator >= (BigInteger b);",
			"    bool operator <= (BigInteger b);",
			"    BigInteger& operator ++(); // prefix",
			"    BigInteger  operator ++(int); // postfix",
			"    BigInteger& operator --(); // prefix",
			"    BigInteger  operator --(int); // postfix",
			"    BigInteger operator + (BigInteger b);",
			"    BigInteger operator - (BigInteger b);",
			"    BigInteger operator * (BigInteger b);",
			"    BigInteger operator / (BigInteger b);",
			"    BigInteger operator % (BigInteger b);",
			"    BigInteger& operator += (BigInteger b);",
			"    BigInteger& operator -= (BigInteger b);",
			"    BigInteger& operator *= (BigInteger b);",
			"    BigInteger& operator /= (BigInteger b);",
			"    BigInteger& operator %= (BigInteger b);",
			"    BigInteger& operator [] (int n);",
			"    BigInteger operator -(); // unary minus sign",
			"    operator string(); // for conversion from BigInteger to string",
			"private:",
			"    bool equals(BigInteger n1, BigInteger n2);",
			"    bool less(BigInteger n1, BigInteger n2);",
			"    bool greater(BigInteger n1, BigInteger n2);",
			"    string add(string number1, string number2);",
			"    string subtract(string number1, string number2);",
			"    string multiply(string n1, string n2);",
			"    pair<string, long long> divide(string n, long long den);",
			"    string toString(long long n);",
			"    long long toInt(string s);",
			"};",
			"",
			"",
			"",
			"//------------------------------------------------------------------------------",
			"",
			"BigInteger::BigInteger() { // empty constructor initializes zero",
			"    number = \"0\";",
			"    sign = false;",
			"}",
			"",
			"BigInteger::BigInteger(string s) { // \"string\" constructor",
			"    if( isdigit(s[0]) ) { // if not signed",
			"        setNumber(s);",
			"        sign = false; // +ve",
			"    } else {",
			"        setNumber( s.substr(1) );",
			"        sign = (s[0] == '-');",
			"    }",
			"}",
			"",
			"BigInteger::BigInteger(string s, bool sin) { // \"string\" constructor",
			"    setNumber( s );",
			"    setSign( sin );",
			"}",
			"",
			"BigInteger::BigInteger(int n) { // \"int\" constructor",
			"    stringstream ss;",
			"    string s;",
			"    ss << n;",
			"    ss >> s;",
			"",
			"",
			"    if( isdigit(s[0]) ) { // if not signed",
			"        setNumber( s );",
			"        setSign( false ); // +ve",
			"    } else {",
			"        setNumber( s.substr(1) );",
			"        setSign( s[0] == '-' );",
			"    }",
			"}",
			"",
			"void BigInteger::setNumber(string s) {",
			"    number = s;",
			"}",
			"",
			"const string& BigInteger::getNumber() { // retrieves the number",
			"    return number;",
			"}",
			"",
			"void BigInteger::setSign(bool s) {",
			"    sign = s;",
			"}",
			"",
			"const bool& BigInteger::getSign() {",
			"    return sign;",
			"}",
			"",
			"BigInteger BigInteger::absolute() {",
			"    return BigInteger( getNumber() ); // +ve by default",
			"}",
			"",
			"void BigInteger::operator = (BigInteger b) {",
			"    setNumber( b.getNumber() );",
			"    setSign( b.getSign() );",
			"}",
			"",
			"bool BigInteger::operator == (BigInteger b) {",
			"    return equals((*this) , b);",
			"}",
			"",
			"bool BigInteger::operator != (BigInteger b) {",
			"    return ! equals((*this) , b);",
			"}",
			"",
			"bool BigInteger::operator > (BigInteger b) {",
			"    return greater((*this) , b);",
			"}",
			"",
			"bool BigInteger::operator < (BigInteger b) {",
			"    return less((*this) , b);",
			"}",
			"",
			"bool BigInteger::operator >= (BigInteger b) {",
			"    return equals((*this) , b)",
			"           || greater((*this), b);",
			"}",
			"",
			"bool BigInteger::operator <= (BigInteger b) {",
			"    return equals((*this) , b)",
			"           || less((*this) , b);",
			"}",
			"",
			"BigInteger& BigInteger::operator ++() { // prefix",
			"    (*this) = (*this) + 1;",
			"    return (*this);",
			"}",
			"",
			"BigInteger BigInteger::operator ++(int) { // postfix",
			"    BigInteger before = (*this);",
			"",
			"    (*this) = (*this) + 1;",
			"",
			"    return before;",
			"}",
			"",
			"BigInteger& BigInteger::operator --() { // prefix",
			"    (*this) = (*this) - 1;",
			"    return (*this);",
			"",
			"}",
			"",
			"BigInteger BigInteger::operator --(int) { // postfix",
			"    BigInteger before = (*this);",
			"",
			"    (*this) = (*this) - 1;",
			"",
			"    return before;",
			"}",
			"",
			"BigInteger BigInteger::operator + (BigInteger b) {",
			"    BigInteger addition;",
			"    if( getSign() == b.getSign() ) { // both +ve or -ve",
			"        addition.setNumber( add(getNumber(), b.getNumber() ) );",
			"        addition.setSign( getSign() );",
			"    } else { // sign different",
			"        if( absolute() > b.absolute() ) {",
			"            addition.setNumber( subtract(getNumber(), b.getNumber() ) );",
			"            addition.setSign( getSign() );",
			"        } else {",
			"            addition.setNumber( subtract(b.getNumber(), getNumber() ) );",
			"            addition.setSign( b.getSign() );",
			"        }",
			"    }",
			"    if(addition.getNumber() == \"0\") // avoid (-0) problem",
			"        addition.setSign(false);",
			"",
			"    return addition;",
			"}",
			"",
			"BigInteger BigInteger::operator - (BigInteger b) {",
			"    b.setSign( ! b.getSign() ); // x - y = x + (-y)",
			"    return (*this) + b;",
			"}",
			"",
			"BigInteger BigInteger::operator * (BigInteger b) {",
			"    BigInteger mul;",
			"",
			"    mul.setNumber( multiply(getNumber(), b.getNumber() ) );",
			"    mul.setSign( getSign() != b.getSign() );",
			"",
			"    if(mul.getNumber() == \"0\") // avoid (-0) problem",
			"        mul.setSign(false);",
			"",
			"    return mul;",
			"}",
			"",
			"// Warning: Denomerator must be within \"long long\" size not \"BigInteger\"",
			"BigInteger BigInteger::operator / (BigInteger b) {",
			"    long long den = toInt( b.getNumber() );",
			"    BigInteger div;",
			"",
			"    div.setNumber( divide(getNumber(), den).first );",
			"    div.setSign( getSign() != b.getSign() );",
			"",
			"    if(div.getNumber() == \"0\") // avoid (-0) problem",
			"        div.setSign(false);",
			"",
			"    return div;",
			"}",
			"",
			"// Warning: Denomerator must be within \"long long\" size not \"BigInteger\"",
			"BigInteger BigInteger::operator % (BigInteger b) {",
			"    long long den = toInt( b.getNumber() );",
			"",
			"    BigInteger rem;",
			"    long long rem_int = divide(number, den).second;",
			"    rem.setNumber( toString(rem_int) );",
			"    rem.setSign( getSign() != b.getSign() );",
			"",
			"    if(rem.getNumber() == \"0\") // avoid (-0) problem",
			"        rem.setSign(false);",
			"",
			"    return rem;",
			"}",
			"",
			"BigInteger& BigInteger::operator += (BigInteger b) {",
			"    (*this) = (*this) + b;",
			"    return (*this);",
			"}",
			"",
			"BigInteger& BigInteger::operator -= (BigInteger b) {",
			"    (*this) = (*this) - b;",
			"    return (*this);",
			"}",
			"",
			"BigInteger& BigInteger::operator *= (BigInteger b) {",
			"    (*this) = (*this) * b;",
			"    return (*this);",
			"}",
			"",
			"BigInteger& BigInteger::operator /= (BigInteger b) {",
			"    (*this) = (*this) / b;",
			"    return (*this);",
			"}",
			"",
			"BigInteger& BigInteger::operator %= (BigInteger b) {",
			"    (*this) = (*this) % b;",
			"    return (*this);",
			"}",
			"",
			"BigInteger& BigInteger::operator [] (int n) {",
			"    return *(this + (n*sizeof(BigInteger)));",
			"}",
			"",
			"BigInteger BigInteger::operator -() { // unary minus sign",
			"    return (*this) * -1;",
			"}",
			"",
			"BigInteger::operator string() { // for conversion from BigInteger to string",
			"    string signedString = ( getSign() ) ? \"-\" : \"\"; // if +ve, don't print + sign",
			"    signedString += number;",
			"    return signedString;",
			"}",
			"",
			"bool BigInteger::equals(BigInteger n1, BigInteger n2) {",
			"    return n1.getNumber() == n2.getNumber()",
			"           && n1.getSign() == n2.getSign();",
			"}",
			"",
			"bool BigInteger::less(BigInteger n1, BigInteger n2) {",
			"    bool sign1 = n1.getSign();",
			"    bool sign2 = n2.getSign();",
			"",
			"    if(sign1 && ! sign2) // if n1 is -ve and n2 is +ve",
			"        return true;",
			"",
			"    else if(! sign1 && sign2)",
			"        return false;",
			"",
			"    else if(! sign1) { // both +ve",
			"        if(n1.getNumber().length() < n2.getNumber().length() )",
			"            return true;",
			"        if(n1.getNumber().length() > n2.getNumber().length() )",
			"            return false;",
			"        return n1.getNumber() < n2.getNumber();",
			"    } else { // both -ve",
			"        if(n1.getNumber().length() > n2.getNumber().length())",
			"            return true;",
			"        if(n1.getNumber().length() < n2.getNumber().length())",
			"            return false;",
			"        return n1.getNumber().compare( n2.getNumber() ) > 0; // greater with -ve sign is LESS",
			"    }",
			"}",
			"",
			"bool BigInteger::greater(BigInteger n1, BigInteger n2) {",
			"    return ! equals(n1, n2) && ! less(n1, n2);",
			"}",
			"",
			"string BigInteger::add(string number1, string number2) {",
			"    string add = (number1.length() > number2.length()) ?  number1 : number2;",
			"    char carry = '0';",
			"    int differenceInLength = abs( (int) (number1.size() - number2.size()) );",
			"",
			"    if(number1.size() > number2.size())",
			"        number2.insert(0, differenceInLength, '0'); // put zeros from left",
			"",
			"    else// if(number1.size() < number2.size())",
			"        number1.insert(0, differenceInLength, '0');",
			"",
			"    for(int i=number1.size()-1; i>=0; --i) {",
			"        add[i] = ((carry-'0')+(number1[i]-'0')+(number2[i]-'0')) + '0';",
			"",
			"        if(i != 0) {",
			"            if(add[i] > '9') {",
			"                add[i] -= 10;",
			"                carry = '1';",
			"            } else",
			"                carry = '0';",
			"        }",
			"    }",
			"    if(add[0] > '9') {",
			"        add[0]-= 10;",
			"        add.insert(0,1,'1');",
			"    }",
			"    return add;",
			"}",
			"",
			"string BigInteger::subtract(string number1, string number2) {",
			"    string sub = (number1.length()>number2.length())? number1 : number2;",
			"    int differenceInLength = abs( (int)(number1.size() - number2.size()) );",
			"",
			"    if(number1.size() > number2.size())",
			"        number2.insert(0, differenceInLength, '0');",
			"",
			"    else",
			"        number1.insert(0, differenceInLength, '0');",
			"",
			"    for(int i=number1.length()-1; i>=0; --i) {",
			"        if(number1[i] < number2[i]) {",
			"            number1[i] += 10;",
			"            number1[i-1]--;",
			"        }",
			"        sub[i] = ((number1[i]-'0')-(number2[i]-'0')) + '0';",
			"    }",
			"",
			"    while(sub[0]=='0' && sub.length()!=1) // erase leading zeros",
			"        sub.erase(0,1);",
			"",
			"    return sub;",
			"}",
			"",
			"string BigInteger::multiply(string n1, string n2) {",
			"    if(n1.length() > n2.length())",
			"        n1.swap(n2);",
			"",
			"    string res = \"0\";",
			"    for(int i=n1.length()-1; i>=0; --i) {",
			"        string temp = n2;",
			"        int currentDigit = n1[i]-'0';",
			"        int carry = 0;",
			"",
			"        for(int j=temp.length()-1; j>=0; --j) {",
			"            temp[j] = ((temp[j]-'0') * currentDigit) + carry;",
			"",
			"            if(temp[j] > 9) {",
			"                carry = (temp[j]/10);",
			"                temp[j] -= (carry*10);",
			"            } else",
			"                carry = 0;",
			"",
			"            temp[j] += '0'; // back to string mood",
			"        }",
			"",
			"        if(carry > 0)",
			"            temp.insert(0, 1, (carry+'0'));",
			"",
			"        temp.append((n1.length()-i-1), '0'); // as like mult by 10, 100, 1000, 10000 and so on",
			"",
			"        res = add(res, temp); // O(n)",
			"    }",
			"",
			"    while(res[0] == '0' && res.length()!=1) // erase leading zeros",
			"        res.erase(0,1);",
			"",
			"    return res;",
			"}",
			"",
			"pair<string, long long> BigInteger::divide(string n, long long den) {",
			"    long long rem = 0;",
			"    string result;",
			"    result.resize(BI_MAX);",
			"",
			"    for(int indx=0, len = n.length(); indx<len; ++indx) {",
			"        rem = (rem * 10) + (n[indx] - '0');",
			"        result[indx] = rem / den + '0';",
			"        rem %= den;",
			"    }",
			"    result.resize( n.length() );",
			"",
			"    while( result[0] == '0' && result.length() != 1)",
			"        result.erase(0,1);",
			"",
			"    if(result.length() == 0)",
			"        result = \"0\";",
			"",
			"    return make_pair(result, rem);",
			"}",
			"",
			"string BigInteger::toString(long long n) {",
			"    stringstream ss;",
			"    string temp;",
			"",
			"    ss << n;",
			"    ss >> temp;",
			"",
			"    return temp;",
			"}",
			"",
			"long long BigInteger::toInt(string s) {",
			"    long long sum = 0;",
			"",
			"    for(int i=0; i<s.length(); i++)",
			"        sum = (sum*10) + (s[i] - '0');",
			"",
			"    return sum;",
			"}",
		],
		"description": "cpp BigInteger implementation"
	},
}